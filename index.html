<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chrono.io</title>
    <style>
        :root {
            --bg-color: #000;
            --primary-color: #fff;
            --secondary-color: #333;
            --secondary-hover: #555;
            --accent-color: #f00;

            --face-size: 400px;
            --face-border: 4px;
            --center-dot-size: 12px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-color);
            color: var(--primary-color);
            font-family: monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .ui-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: row-reverse;
            gap: 10px;
        }

        .btn {
            background: var(--secondary-color);
            color: var(--primary-color);
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-family: monospace;
            transition: background 0.2s ease;
        }

        .btn:hover { background: var(--secondary-hover); }

        #hideBtn { position: fixed; bottom: 20px; left: 20px; padding: 8px 12px; font-size: 16px; }

        .ui-hidden .ui-controls, .ui-hidden #hideBtn { display: none; }

        .state-digital #mode, .state-digital #numbers { display: none; }
        .state-analog #format { display: none; }

        #digital { font-size: 80px; letter-spacing: 5px; }
        .state-digital #analog { display: none; }
        .state-analog #digital { display: none; }

        .clock-face {
            width: var(--face-size);
            height: var(--face-size);
            border: var(--face-border) solid var(--primary-color);
            border-radius: 50%;
            position: relative;
        }

        .marker {
            position: absolute;
            background: var(--primary-color);
            left: 50%;
            top: 0;
            transform-origin: center calc(var(--face-size) / 2);
        }

        .hour-marker { width: 4px; height: 20px; margin-left: -2px; }
        .minute-marker { width: 2px; height: 10px; margin-left: -1px; }

        .hand {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform-origin: bottom center;
            background: var(--primary-color);
            transform: translateX(-50%) rotate(var(--rotation-angle, 0deg));
        }

        .hour { width: 6px; height: 120px; }
        .minute { width: 4px; height: 160px; }
        .second { width: 2px; height: 180px; background: var(--accent-color); }

        .center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: var(--center-dot-size);
            height: var(--center-dot-size);
            background: var(--primary-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .number {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            display: none;
            align-items: center;
            justify-content: center;
            margin-left: -20px;
            margin-top: -20px;
            font-size: 24px;
            font-weight: bold;
        }
        .show-numbers .number { display: flex; }
    </style>
</head>
<body class="state-digital">
    <div class="ui-controls">
        <button id="toggle" class="btn">ANALOG</button>
        <button id="format" class="btn">12H</button>
        <button id="mode" class="btn">GLIDE</button>
        <button id="numbers" class="btn">NUMBERS</button>
        <button id="timeSource" class="btn">NETWORK</button>
    </div>
    <button id="hideBtn" class="btn">HIDE</button>

    <div id="digital">00:00:00</div>

    <div id="analog">
        <div class="clock-face">
            <div id="markers"></div>
            <div id="clockNumbers"></div>
            <div class="hand hour" id="hour"></div>
            <div class="hand minute" id="minute"></div>
            <div class="hand second" id="second"></div>
            <div class="center"></div>
        </div>
    </div>

    <script>
        const DOM = {
            body: document.body,
            digital: document.getElementById('digital'),
            analog: document.getElementById('analog'),
            toggle: document.getElementById('toggle'),
            format: document.getElementById('format'),
            mode: document.getElementById('mode'),
            numbers: document.getElementById('numbers'),
            timeSource: document.getElementById('timeSource'),
            hide: document.getElementById('hideBtn'),
            hands: {
                hour: document.getElementById('hour'),
                minute: document.getElementById('minute'),
                second: document.getElementById('second')
            },
            markers: document.getElementById('markers'),
            clockNumbers: document.getElementById('clockNumbers'),
            uiControls: document.querySelector('.ui-controls')
        };

        const STATE = {
            isDigital: true,
            isGliding: false,
            showNumbers: false,
            is24Hour: true,
            uiHidden: false,
            // DEFAULT TO NETWORK TIME
            useNetworkTime: true,
            networkTimeOffset: 0, // ms
            tickInterval: null,
            animationFrame: null,
            periodicSyncId: null
        };

        // config for retries & periodic sync
        const SYNC_CONFIG = {
            endpoint: 'https://time.now/developer/api/ip',
            maxAttempts: 5,
            initialDelayMs: 1000,   // backoff start
            periodicSyncMs: 5 * 60 * 1000 // 5 minutes
        };

        // helper sleep
        const sleep = ms => new Promise(res => setTimeout(res, ms));

        /**
         * Fetch network time with latency compensation and retries (exponential backoff).
         * Returns true if sync succeeded, false otherwise.
         */
        async function fetchNetworkTimeWithRetries(maxAttempts = SYNC_CONFIG.maxAttempts, initialDelay = SYNC_CONFIG.initialDelayMs) {
            let attempt = 0;
            let delay = initialDelay;

            while (attempt < maxAttempts) {
                attempt++;
                try {
                    DOM.timeSource.textContent = attempt === 1 ? 'SYNCING...' : `SYNCING (${attempt})...`;
                    // measure local send time
                    const t0 = Date.now();
                    const resp = await fetch(SYNC_CONFIG.endpoint, { cache: 'no-store' });
                    const t1 = Date.now(); // receive time
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    const data = await resp.json();

                    // parse server time
                    let serverMs;
                    if (data.utc_datetime) {
                        serverMs = Date.parse(data.utc_datetime);
                    } else if (typeof data.unixtime === 'number') {
                        serverMs = data.unixtime * 1000;
                    } else {
                        serverMs = Date.parse(data.datetime || data.utc_datetime);
                    }

                    if (Number.isNaN(serverMs)) throw new Error('Invalid network time');

                    // RTT compensation: assume server timestamp was taken around response generation,
                    // so add half the measured RTT to approximate "now".
                    const rtt = t1 - t0;
                    const estimatedNetworkNowMs = serverMs + Math.round(rtt / 2);

                    const systemMs = t1;
                    STATE.networkTimeOffset = estimatedNetworkNowMs - systemMs;

                    console.log(`Sync success (attempt ${attempt}). RTT=${rtt}ms offset=${STATE.networkTimeOffset}ms`);
                    return true;
                } catch (err) {
                    console.warn(`Sync attempt ${attempt} failed:`, err);
                    if (attempt >= maxAttempts) break;
                    await sleep(delay);
                    delay *= 2; // exponential backoff
                }
            }
            return false;
        }

        function schedulePeriodicSync() {
            clearPeriodicSync();
            STATE.periodicSyncId = setInterval(async () => {
                // attempt a single quick sync; if it fails we keep using previous offset
                console.log('Periodic sync triggered');
                const ok = await fetchNetworkTimeWithRetries(2, 500); // small retry budget
                if (!ok) console.warn('Periodic sync failed (kept previous offset).');
                else console.log('Periodic sync succeeded (offset updated).');
            }, SYNC_CONFIG.periodicSyncMs);
        }

        function clearPeriodicSync() {
            if (STATE.periodicSyncId) {
                clearInterval(STATE.periodicSyncId);
                STATE.periodicSyncId = null;
            }
        }

        async function fetchNetworkTime() {
            // wrapper that uses configured retry policy and manages periodic resync on success/failure
            const success = await fetchNetworkTimeWithRetries();
            if (success) {
                STATE.useNetworkTime = true;
                updateClock();
                schedulePeriodicSync();
                renderUI();
                return true;
            } else {
                // fall back to system time
                STATE.useNetworkTime = false;
                clearPeriodicSync();
                renderUI();
                return false;
            }
        }

        function getCurrentTime() {
            const systemTime = new Date();
            if (STATE.useNetworkTime) {
                return new Date(systemTime.getTime() + STATE.networkTimeOffset);
            }
            return systemTime;
        }

        function updateClock() {
            const now = getCurrentTime();
            const time = {
                hours: now.getHours(),
                minutes: now.getMinutes(),
                seconds: now.getSeconds(),
                milliseconds: STATE.isGliding ? now.getMilliseconds() : 0
            };
            updateDigitalClock(time);
            updateAnalogClock(time);
        }

        function updateDigitalClock({ hours, minutes, seconds }) {
            const pad = n => n.toString().padStart(2, '0');
            let displayHours = hours;
            let suffix = '';
            if (!STATE.is24Hour) {
                suffix = hours >= 12 ? ' PM' : ' AM';
                displayHours = hours % 12 || 12;
            }
            DOM.digital.textContent = `${pad(displayHours)}:${pad(minutes)}:${pad(seconds)}${suffix}`;
        }

        function updateAnalogClock({ hours, minutes, seconds, milliseconds }) {
            const secondsWithMs = seconds + milliseconds / 1000;
            const minutesWithSeconds = minutes + secondsWithMs / 60;
            const hoursWithMinutes = (hours % 12) + minutesWithSeconds / 60;

            const angles = {
                second: secondsWithMs * 6,
                minute: minutesWithSeconds * 6,
                hour: hoursWithMinutes * 30
            };

            DOM.hands.second.style.setProperty('--rotation-angle', `${angles.second}deg`);
            DOM.hands.minute.style.setProperty('--rotation-angle', `${angles.minute}deg`);
            DOM.hands.hour.style.setProperty('--rotation-angle', `${angles.hour}deg`);
        }

        function animate() {
            updateClock();
            if (STATE.isGliding) {
                STATE.animationFrame = requestAnimationFrame(animate);
            }
        }

        function renderUI() {
            DOM.body.classList.toggle('state-digital', STATE.isDigital);
            DOM.body.classList.toggle('state-analog', !STATE.isDigital);
            DOM.body.classList.toggle('ui-hidden', STATE.uiHidden);

            DOM.clockNumbers.classList.toggle('show-numbers', STATE.showNumbers);

            DOM.toggle.textContent = STATE.isDigital ? 'ANALOG' : 'DIGITAL';
            DOM.format.textContent = STATE.is24Hour ? '12H' : '24H';
            DOM.mode.textContent = STATE.isGliding ? 'TICK' : 'GLIDE';
            DOM.numbers.textContent = STATE.showNumbers ? 'MARKERS' : 'NUMBERS';
            // show NETWORK when using network time, SYSTEM when using local system time
            DOM.timeSource.textContent = STATE.useNetworkTime ? 'NETWORK' : 'SYSTEM';
        }

        function toggleClockMode() { STATE.isDigital = !STATE.isDigital; renderUI(); }

        function toggleTimeFormat() { STATE.is24Hour = !STATE.is24Hour; updateClock(); renderUI(); }

        function toggleGlideMode() {
            STATE.isGliding = !STATE.isGliding;
            if (STATE.isGliding) {
                clearInterval(STATE.tickInterval);
                STATE.tickInterval = null;
                animate();
            } else {
                cancelAnimationFrame(STATE.animationFrame);
                STATE.animationFrame = null;
                updateClock();
                if (!STATE.tickInterval) STATE.tickInterval = setInterval(updateClock, 1000);
            }
            renderUI();
        }

        function toggleNumbers() { STATE.showNumbers = !STATE.showNumbers; renderUI(); }

        function toggleUIVisibility() { STATE.uiHidden = !STATE.uiHidden; renderUI(); }

        async function toggleTimeSource() {
            const wantNetwork = !STATE.useNetworkTime;
            if (wantNetwork) {
                // switching to network time: try to sync (with retries)
                DOM.timeSource.textContent = 'SYNCING...';
                const ok = await fetchNetworkTime();
                if (!ok) {
                    DOM.timeSource.textContent = 'FAILED';
                    setTimeout(() => renderUI(), 1500);
                    return;
                }
            } else {
                // switching to system time: stop periodic sync and use system immediately
                STATE.useNetworkTime = false;
                clearPeriodicSync();
                updateClock();
            }
            renderUI();
        }

        function attachEventListeners() {
            DOM.toggle.addEventListener('click', toggleClockMode);
            DOM.format.addEventListener('click', toggleTimeFormat);
            DOM.mode.addEventListener('click', toggleGlideMode);
            DOM.numbers.addEventListener('click', toggleNumbers);
            DOM.hide.addEventListener('click', toggleUIVisibility);
            DOM.timeSource.addEventListener('click', toggleTimeSource);
        }

        function generateMarkers() {
            const fragment = document.createDocumentFragment();
            for (let i = 0; i < 60; i++) {
                const marker = document.createElement('div');
                const isHourMarker = i % 5 === 0;
                marker.className = `marker ${isHourMarker ? 'hour-marker' : 'minute-marker'}`;
                marker.style.transform = `rotate(${i * 6}deg)`;
                fragment.appendChild(marker);
            }
            DOM.markers.appendChild(fragment);
        }

        function generateNumbers() {
            const RADIUS = 150;
            const fragment = document.createDocumentFragment();
            for (let i = 1; i <= 12; i++) {
                const num = document.createElement('div');
                num.className = 'number';
                const angle = (i * 30 - 90) * (Math.PI / 180);
                const x = Math.cos(angle) * RADIUS;
                const y = Math.sin(angle) * RADIUS;
                num.style.transform = `translate(${x}px, ${y}px)`;
                num.textContent = i;
                fragment.appendChild(num);
            }
            DOM.clockNumbers.appendChild(fragment);
        }

        async function init() {
            generateMarkers();
            generateNumbers();
            attachEventListeners();
            renderUI();
            updateClock();
            if (!STATE.tickInterval) STATE.tickInterval = setInterval(updateClock, 1000);

            // Attempt an automatic network sync on load, with retries.
            if (STATE.useNetworkTime) {
                DOM.timeSource.textContent = 'SYNCING...';
                const ok = await fetchNetworkTime();
                if (!ok) {
                    // fallback to system time briefly show FAILED
                    STATE.useNetworkTime = false;
                    DOM.timeSource.textContent = 'FAILED';
                    setTimeout(() => renderUI(), 1500);
                } else {
                    renderUI();
                }
            }
        }

        // Start
        init();
    </script>
</body>
</html>
